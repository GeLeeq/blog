---
layout: post
title:  scala初级教程
date:   2016-10-10 18:03:07
category: "计算机语言"
---

# 简介 
Scala 是 Scalable Language 的简写，是一门多范式的编程语言  
联邦理工学院洛桑（EPFL）的Martin Odersky于2001年基于Funnel的工作开始设计Scala。Funnel是把函数式编程思想和Petri网相结合的一种编程语言。  
Odersky先前的工作是Generic Java和javac（Sun Java编译器）。Java平台的Scala于2003年底/2004年初发布。.NET平台的Scala发布于2004年6月。该语言第二个版本，v2.0，发布于2006年3月。  
截至2009年9月，最新版本是版本2.7.6 。Scala 2.8预计的特性包括重写的Scala类库（Scala collections library）、方法的命名参数和默认参数、包对象（package object），以及Continuation。  
2009年4月，Twitter宣布他们已经把大部分后端程序从Ruby迁移到Scala，其余部分也打算要迁移。此外， Wattzon已经公开宣称，其整个平台都已经是基于Scala基础设施编写的。

# 第一个Scala程序（HelloWorld.scala）
	object HelloWorld {
    	def main(args: Array[String]): Unit = {
    	    println("Hello, world!")
    	}
	}

# 1 基础
## 1.1 scala解释器
- 安装Scala之前，需要安装Java（>1.5版本）
- 安装Scala，配置bin目录到PATH环境变量
- 运行Scala，使用REPL环境（读取->求值->打印->循环）

		scala> 8 * 5 + 2
		res0: Int = 42
## 1.2 值和变量
定义值或常量

	scala> val answer = 8 * 5 + 2
    answer: Int = 42
定义变量
	
	scala> var counter = 0
    scala> counter = 1 //OK, 我们可以改变一个var
> 1.声明值或变量不做初始化会报错  
> 2.在必要时可以指定类型:  
> `val word: String = null`

多个值或变量一起声明
	
	val x, y = 100 //x和y设为100
## 1.3 常用类型
7种数值类型：`Byte` `Char` `Short` `Int` `Long` `Float` `Double`

这些类型也都是类，与java不同的是，Scala并不区分基本类型和引用类型。

最后，还有BigInt和BigDecimal类，任意大小（有穷）的数字。

> 基本类型和包装类型的转换是Scala编译器的工作。  
> 我们用方法，而不是强制类型转换来做数值类型之间的转换：  
> `99.44.toInt`得到99， `99.toChar`得到`c`

`StringOps`、`RichInt`、`RichDouble`、`RichChar`等类为相应的数值类型追加了上百种操作：

	"Hello".intersect("World") //隐式转换为StringOps，输出"lo"
	1.to(10) //隐式转换为RichInt，输出Range(1,2,3,4,5,6,7,8,9,10)

## 1.4 算术和操作符重载
+-*/ 这些操作符实际上是方法。

		a+b
    是如下方法调用的简写：
		a.+(b)

	通常来说，你可以用
		a 方法 b
    作为以下代码的简写:
		a.方法(b)
	如： 1.to(10) 可简写为 1 to 10

>注意：scala不提供++和--操作符，你只可以使用+=1 或者 -=1，  
>因为无法简单的实现一个名为++的方法，因为Int类是不可变的，scala设计者认为不必要为这个而增加一个特例。

BigInt和BigDecimal对象，将比使用java的对应的这两个类更方便:
	
	//scala
	val x: BigInt = 1234567890
	x * x * x
    //java
	x.multiply(x).multiply(x)

最后，Scala允许你定义操作符，由你来决定是否要在必要时有分寸地使用这个特性。

## 1.5 调用函数和方法

	import scala.math._ //在Scala中，_字符是“通配符”，类似java中的*

	sqlrt(2) //开根号
	pow(2,4)
	min(3, Pi)

>你不需要从某个类调用它的静态方法，实际上Scala没有静态方法，不过它有个类似的特性，叫做 `单例对象(singleton object)`，第6章节讲

不带参数的Scala方法通过不使用圆括号：
	
	"Hello".distinct //StringOps类的distinct方法
>一般来讲，没有参数且不改变当前对象的方法不带圆括号，第5章节讲

## 1.6 apply方法
	"Hello"(4) //将产出'o'
	等同于
	"Hello".apply(4)
可以认为这种用法是`()`操作符的重载。在StringOps类中，有这样一个方法：

	def apply(n: Int): Char

如果看，`BigInt的伴生对象`的源码，你会看到将字符串或数据转换为BigInt对象的apply方法。
举例来说：

	BigInt("1234567890") // 实际是BigInt.apply("1234567890")
	调用的是BigInt伴生对象的apply方法，返回一个新的BigInt对象。注意，这里不需要使用new
	
## 1.7 Scaladoc
[http://scala-lang.org/api/](http://scala-lang.org/api/)

# 2 控制结构和函数

## 2.1 条件表达式

Scala不同的是，if表达式有值，值就是跟在if或else之后的表达式的值。

	val s = if(x > 0) 1 else -1
	等价于
	var s = 0
    if(x > 0) s = 1 else s = -1 //s必须是var

>REPL中要换行的话，可以使用花括号。或键入`:paste`进入粘贴模型

	if(x > 0) 1 else () //每个表达式都应该有某种值。解决：引入一个Unit类，写做()，表示“无有用值”的点位符

>Scala没有swithc语句，不过它有更强大得多的模式匹配机制，第14章节讲。
## 2.2 语句终止

	行尾的位置不需要分号，仅当单行中写多个语句：

	if(n > 0){
		r = r * n
		n -= 1
	}

	if(n > 0){ r = r * n; n -= 1}

	较长语句，分成二行（使用操作符告诉解析器）：
	s = s0 + (v - v0) * t +
		0.5 * (a - a0) * t * t


## 2.3 块
在Scala中，{}块包含一系列表达式，其`结果`也是一个表达式。块中最后一个表达式的值就是块的`值`

	val distance = { val x = 1; var y = 2; x + y; x - y } //distance = -1

赋值语句的值是Unit类型，而Unit类型只有一个值,写做()

	val x = y = 1 //别这样做, 没意义

## 2.4 输入输出
	val name = readLine("your name: ") //类似还有，readInt、readDouble，...不同的是readLine带一个提示参数
	print("your age: ") //不换行, println函数换行
	val age = readInt()
	printf("hello, %s! Next year, you will be %d. \n", name, age + 1) //C风格的printf函数

## 2.5 循环
和java或C++相同的while和do循环，Scala没有像java那样的结构的for循环，Scala的for更强大。

	scala的基本for循环：
		for(i <- 表达式）
	让变量i遍历<-右边表达式的所有值，遍历什么取决于表达式。对于Scala集合比如Range而言，这个循环会让i依次取得区间中的每个值。
		for(i <- 1 to 10)
			r = r * i
	unitl关键字，方法返回一个并不包含上限的区间
		for(i <- 0 unitil 10) // [0, 10)
            r = r * i
	我们可以直接遍历一个字符串
		var sum = 0
		for(ch <- "Hello") sum += ch //sum输出500

>Scala并没有提供break和continue语句来退出循环。  
>替代方法有三种： 

> 1使用Boolean型的控制变量  
> 2使用嵌套函数----使你可以从函数当中return  
> 3使用scala.util.control.Breaks对象中的方法：  

	breakable{
		for(...){
			if(...) break; //退出breakable块
			...
		}
	}
	这里是通过抛出和捕获异常来完成的，尽量避免使用，相对耗时。

高级for循环与for的推导式：
	
	多个`生成器`（变量<-表达式）
	for(i <- 1 to 3; j <- 1 to 3) print ((10 * i + j) + " ")
	
	每个`生成器`都可以带一个`守卫`，以if开头的Boolean表达式
	for(i <- 1 to 3; j <- 1 to 3 if i != j) print ((10 * i + j) + " ")
	
	可以使用任意多的`定义`
	for(i <- 1 to 3; from = 4 - i j <- from to 3) print ((10 * i + j) + " ")
	
	循环体以`yield`关键字开始，这类循环叫做`for推导式`
	for(i <- 1 to 10) yield i % 3 //生成 Vector(1,2,0,1,2,0,1,2,0,1)

	你可以用换行的方式而不是分号来隔开生成器、守卫及定义
	for{ i <- 1 to 3
		from = 4 - i
		j <- from to 3
	}

## 2.6 函数
Scala除了方法还有函数，方法是对对象进行操作，函数不是。

Scala不需要return，但也可以使用return来立即退出函数，但并不常见（还浪费输入r e t u r n的时间）。  
应该把return当做是函数版本的break语句来看待，仅在需要时使用。 

定义函数： 

	def abs(x: Double) = if(x >= 0) x else -x
	
	def fac(n: Int): Int = if(n <= 0) 1 else n * fac(n - 1)
`函数名`、`参数`、`函数体`是必须的，仅当是`递归函数`才需要函数的`返回类型`

	函数的默认参数
	def decorate(str: String, left: String = "[", right: String = "]") = {
		left + str + right
	}
	decorate("Hello") //"[Hello]"
	
	带名参数，不需要跟参数列表的顺序一样
	decorate(left = "<<<", str = "Hello", right = ">>>") //"[Hello]"

	混用未命名参数和带名参数，需要保证未命名的参数排在前面
	decorate("Hello", rigtht = "]<<<") //"[Hello]<<<"

变长参数：

	def sum(args: Int*) = {
		var result = 0
		for(arg <- args) result += arg
		result 
	}
	val s = sum(1, 4, 9, 16, 25)
	函数得到的是一个类型为Seq的参数，可以用for循环来访问每个元素。

	如果你已经有一个序列，如：1 to 5，不能直接传给以上变长参数的函数，使用_*告诉编译器我要转化为参数序列
	val s = sum(1 to 5: _*) //将1 to 5当做参数序列处理

什么叫过程?

	def box(s: String) { //没有=号
		println(s)
	}
	如果函数体包含在花括号当中，但没有前面的=号，那么返回类型就是Unit，这样的函数称为过程(procedure)

	def box(s: String): Unit = {
		...
	}
	或者显式声明返回Unit类型
